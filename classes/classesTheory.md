Какие уровни доступа есть у класса на верхнем уровне, т.е. у внешнего класса?
**Ответ.** На верхнем уровне - public или package-private (без явного указания модификатора).
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html

Что является членами класса?
**Ответ.** Поля, методы и вложенные классы или вложенные интерфейсы.
**Источник.** https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.6

Что еще можно определить в классе кроме членов?
**Ответ.** Конструкторы, статический блок инициализации класса, статический блок инициализации экземпляра.
**Источник.** http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.6

Какие уровни доступа есть у членов класса?
**Ответ.** private, protected, default, public.

Какие уровни доступа есть у членов класса?
**Ответ.** 	private — члены класса доступны только членам данного класса;
			по умолчанию (package-private) — члены класса доступны классам, находящимся в том же пакете;
			protected — члены класса доступны классам, находящимся в том же пакете, и подклассам — в других пакетах;
			public — члены класса доступны для всех классов в этом и других пакетах.
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html

Какие модификаторы необходимы для определения константы:
	1. класса,
	2. экземпляра класса?
**Ответ.** Для класса используется static final, а для экземпляра final.
**Источник.** http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.3.1.1

Обратный вопрос. Допустим, у некоторого класса есть 4 следующих поля:
```Java
	class SomeClass {
    private int a;
    private final int b;
	private static int c;
	private static final int D;
	
	}
```
Как можно назвать данные поля в зависимости от комбинации модификаторов static и final?
**Ответ.**
1. неконстантное поле; 
2. константа экземпляра класса;
3. статическое поле класса;
4. константа класса.

Может ли класс не иметь ни одного конструктора? Почему?
**Ответ.** Конструктор имеется в любом классе. Даже если вы его не написали, компилятор Java
			сам создаст конструктор по умолчанию (default constructor), который будет пустым и не делает ничего,
				кроме вызова конструктора суперкласса.
**Источник.** https://javarush.ru/groups/posts/1391-konstruktorih-klassov-java-jdk-15

Перечислите отличия конструктора от метода.
**Ответ.** 	Конструктор - это специальный метод, который вызывается при создании нового объекта;
			Конструктор имеет такое же название как и класс, но не имеет возвращаемого значения; 
			Конструктор вызывается в месте выполнения оператора new;
			Конструктор нельзя вызвать напрямую из другого метода;
			Конструктор никогда не может возвращать значение (методы void также не возвращают значение);
			Конструктор вызывается при создании экземпляра класса;
			Конструктор не может иметь модификаторы: abstract, static, final, native, strictfp или synchronized.
**Источник.**	https://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html
					http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.8

Как и в каком месте можно вызвать из одного конструктора другой конструктор этого же класса?
**Ответ.** В первой строке конструктора этого же класса при помощи ключевого слова this.
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html

Как и в каком месте можно вызвать конструктор суперкласса?
**Ответ.** В конструкторе подкласса при помощи ключевого слова super. Вызов конструктора суперкласса должен быть в первом строке конструктора подкласса.
**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/super.html

Что делает компилятор, если в конструкторе нет вызова другого конструктора или конструктора суперкласса?
**Ответ.** Компилятор добавит их неявно. Если в суперклассе нет конструктора без аргументов то произойдет ошибка компиляции.
**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/super.html

Можно ли одновременно использовать конструкции this() и super() в одном и том же конструкторе?
	Обоснуйте ответ.
**Ответ.** Нет, так как this(...) вызовет другой конструктор в том же классе, тогда как super() вызовет супер-конструктор. 
Если в конструкторе нет super(), компилятор добавит его неявно.
Таким образом, если бы оба были разрешены, вы могли бы дважды вызвать конструктор super.
**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/super.html
				https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html

Может ли быть приватный уровень доступа у конструктора? Если да, то для каких целей он необходим?
**Ответ.** Да.Это значит, что вы можете управлять тем, как создается экземпляр класса. Если вы сделаете конструктор 
			закрытым, а затем создайте видимый метод конструктора, который возвращает экземпляры класса, вы можете делать 
				такие вещи, как ограничение количества созданий (как правило, гарантируется только один экземпляр) или 
					экземпляры рециркуляции или другие связанные с строительством задачи.
**Источник.** https://fooobar.com/questions/36342/can-a-constructor-in-java-be-private

Какие модификаторы может иметь конструктор?
**Ответ.** В конструкторе допускается применение модификаторов доступа, можно задать один из модификаторов: public, protected, private или без модификатора.
			без модификатора доступа конструктор имеет доступ по умолчанию.
**Источник.** https://javarush.ru/groups/posts/1391-konstruktorih-klassov-java-jdk-15

Конструктор принадлежит классу или экземпляру класса?
**Ответ.** Конструктор принадлежит классу. Но используется экземпляром класса.
**Источник.** https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.8.3

Можно ли наследовать конструктор?
	Если да, то приведите примеры.
**Ответ.** Конструктор похож на метод, но не является методом, он даже не считается членом класса. Поэтому его нельзя наследовать или переопределить в подклассе.
			конструктор не является членом класса поэтому не подлежит сокрытию и переопределению.
**Источник.** https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.8

Какой тип возвращаемого конструктором значения?
**Ответ.** Конструктор не имеет возвращаемого типа, им не может быть даже тип void, если возвращается тип void, 
			то это уже не конструктор а метод, несмотря на совпадение с именем класса.
**Источник.** https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.8

Дан класс.
```Java
	class Null {
		//фрагмент 1
		Null Null() {
			return null;
		}
		//фрагмент 2
		Null() {
			return null;
		}

	}
```
В каком фрагменте ошибка компиляции? 
Удалите этот фрагмент полностью. 
Прокомментируйте оставшийся фрагмент и продемонстрируйте функционал класса.
**Ответ.** В оставшемся фрагменте создается метод Null с типом Null и возвращает объект null.
```Java
	class Null {
	//фрагмент 1
	Null Null() {
		return null;
	}
}
```

Если метод имеет то же имя, как и класс, то каким образом транслятор определяет где метод, а где конструктор (см. пример выше)?
**Ответ.** Если метод имеет то же имя, что и класс, он должен иметь возвращаемый тип. В противном случае, это конструктор.
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html

Дан класс.
```java
	class Name {
		String name;
		Name() {
			this(makeRandomName());
		}
		Name(String name) {
			super();
			this.name = name;
		}
		String makeRandomName() {
			int k = (int) (Math.random() * 3);
			String name = new String[] {"Alpha", "Beta", "Gamma"}[k];
			return name;
		}
		public String toString() {
			return name;
		}
		public static void main(String[] args) {
			System.out.println(new Name());
		}
	}
```
Объясните причину ошибки компиляции. 
Предложите минимум 2 способа исправления ошибки, использовать метод makeRandomName() обязательно.
**Ответ.** Ошибка возникает из-за того что, до того как отработал конструктор по умолчанию - объект еще не создан. 
			Соответственно нельзя получить значения полей не существующего объекта.
вариант1
```Java
class Name{
	String name = makeRandomName();
	Name() {
	}
	Name(String name) {
		super();
		this.name = name;
	}
	
	static String makeRandomName() {
		int k = (int) (Math.random() * 3);
		String name = new String[] {"Alpha", "Beta", "Gamma"}[k];
		return name;
	}
	public String toString() {
		return name;
	}
	public static void main(String[] args) {
		System.out.println(new Name());
	}
}
```
вариант2
```Java
class Name{
	String name;
	  Name() {
	  	this.name=makeRandomName();
	  }
	  Name(String name) {
	  	super();
	  	this.name = name;
	  }

	static String makeRandomName() {
		int k = (int) (Math.random() * 3);
		String name = new String[] {"Alpha", "Beta", "Gamma"}[k];
		return name;
	}
	public String toString() {
		return name;
	}
	public static void main(String[] args) {
		System.out.println(new Name());
	}
}
```

Дан класс.
```java
	class Int {
		int i;
		void inc(Int param) {
			//param = new Int();
			param.i++;
		}
		public static void main(String[] args) {
			Int obj = new Int();
			obj.inc(obj);
			System.out.println(obj.i);
		}
	}
```
Изменится ли результат, если убрать комментарий?
Объясните, почему?
**Ответ.** Если расскоментировать строку param = new Int(), то в переменную param заносится ссылка на другой новосозданный 
			объект. После инкрементируется также значение этого нового объекта, а значение переданного изначально в метод 
				объекта остается как было. Таким образом, после выхода из метода переменная obj продолжит ссылаться 
					на экземпляр класса Int, где i = 0.

В чем смысл конструкции this?
Перечислите случаи, когда используется конструкция this.
В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими возможностями. Если можно, то каким образом?
Если можно, то каким образом?
**Ответ.** Кроме данных и методов каждый экземпляр класса (объект) имеет неявную
			ссылку this на себя, которая передается также неявно и нестатическим методам класса. После этого каждый метод «знает», какой объект его вызвал. Вместо
			обращения к атрибуту id в методах можно писать this.id, хотя и не обязательно, так как записи id и this.id равносильны. Но если в методе объявлена локальная
			переменная или параметр метода с таким же именем, как и поле класса, то для обращения к полю класса использование this обязательно. Без использования
			указателя обращение всегда будет производиться к локальной переменной, так как просто не существует другого способа ее идентификации.
**Источник.** И. Блинов с 58.

Можно ли присвоить null ссылочной переменной this?
Перечислите случаи, когда используется статический блок?
В каких случаях можно обойтись без него. Если можно, то каким образом?
**Ответ.** Нельзя, так как this является ключевым словом языка, означающим ссылку на текущий объект. Логические блоки 
			вызываются при каждом создании экземпляра класса. Его можно использовать для инициализации переменных, а 
				также для вывода в консоль или же вызова методов.
**Источник.** И. Блинов с 65-66. 
					docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.8.3

Перечислите случаи, когда используется статический блок?
В каких случаях можно обойтись без него. Если можно, то каким образом?
**Ответ.** Статический блок – это код, который вызывается только один раз в жизненном цикле приложения при загрузке класса. 
				Может быть использован для:
				- Выполнения некоторых начальных действий перед использованием класса (Например, вычислить какие-либо статические величины, собрать системные данные, подключиться к базе данных или удалённому серверу.);
				- Инициализации статических переменных.
  			Способы избавления от статического блока:
				- при создании объекта - вместо блока можно использовать вызов статического метода;
				- при обращении к статическому методу (полю) данного класса - аналогично;
				- вызовом метода Class.forName(String className) – можно использовать вызов статического метода через ссылку, что является антираттерном. Поэтому статический блок – это отличная альтернатива.
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html

Перечислите случаи, когда используется логический блок? В каких случаях можно обойтись без него. Если можно, то каким образом?  
**Ответ.**  Использование логического блока инициализации гарантирует, что такой блок будет выполнен по мере появления в коде в момент создания объекта класса. Используется если:
				Во время инициализации необходимо обработать проверяемое исключение.
					Значение поля не удобно вычислять с помощью выражения (например, для этого нужен специально созданный класс или метод, который не хочется создавать только для этих целей).
						Необходимо инициализировать поле анонимного класса (в анонимном классе невозможно объявить конструктор).
							Возможна инициализация полей в конструкторе или в месте объявления.
**Источник.** http://www.quizful.net/post/java-fields-initialization

Что входит в сигнатуру метода?  
**Ответ.** В сигнатуру метода входит имя метода, а также передаваемые параметры.
**Источник.** https://javarush.ru/groups/posts/1942-signatura-metoda

Что значит ключевое слово native?  
**Ответ.** Приложение на языке Java может вызывать методы, написанные на языке С++. Такие методы объявляются с ключевым словом native, которое сообщает
			компилятору, что метод реализован в другом месте. Тело собственного метода задается только точкой с запятой, вместо блока, что указывает на то, что реализация опущена.
**Источник**. И. Блинов с 64

Дан код.
```Java
	public class BusinessTrip {
 	 ...
  	public String bynToStr(int value) {
    	return (value / 100) + "." + (value / 10 % 10) + (value % 10);
 	 }
	}
```
Есть ли в нем семантическая ошибка?
Если да, то обоснуйте.  
**Ответ.** Данный метод не использует поля класса, поэтому его надо вынести в утилитный класс и объявить его как static

Дан код.
```java
	public class Utility {
  	private Utility() {
  	}
  	public String bynToStr(int value) {
    	return (value / 100) + "." + (value / 10 % 10) + (value % 10);
  	}
	}
```
Есть ли в нем семантическая ошибка?
Если да, то предложите альтернативные варианты.   
**Ответ.** Метод bynToStr нельзя будет вызвать, так как конструктор класса приватный. Можно сделать этот метод статическим.

К каким данным можно обратиться в статическом методе?  
**Ответ.** К статическим членам класса; к локальным переменным метода; к аргументам метода.
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html

Почему нельзя объявить статическое поле внутри метода?  
**Ответ.** Потому что статическое поле должно принадлежать именно классу, а не методу. Внутри метода объявляются только локальные переменные метода, доступные только внутри метода.
**Источник.** И. Блинов с 61-62.

Перечислите, какой код в классе можно выполнить до создания объекта.  
**Ответ.** Статический блок инициализации.
           	Логический блок инициализации.
			Статические члены класса.

В чем различие между объектом и экземпляром класса?  
**Ответ.** В Java объект - чуть более широкое понятие чем экземпляр класса, включает в себя такие понятия, как “экземпляр класса” и “массив”.
**Источник.** https://docs.oracle.com/javase/specs/jls/se9/html/jls-4.html#jls-4.3.1

Назовите три этапа создания экземпляра класса.  
**Ответ.**	1. Выделение памяти.  
			2. Создание ссылки.  
			3. Инициализация переменных и вызов конструктора.  
**Источник.** https://javarush.ru/groups/posts/2137-porjadok-deystviy-pri-sozdanii-obhhekta

Охарактеризуйте отношение композиции между классами? Как оно реализуется?   
**Ответ.** Композиция позволяет привязать один класс к другому. Её можно реализовать, указав в конструкторе одного класса другой класс.

Допустим, необходимо, чтобы метод возвращал два значения одного примитивного типа.
Предложите способы и подтвердите примерами.
**Ответ.**    
Способ 1 - создать массив
```Java
class Something{
	public int[] something(){
		int number1 = 1;
		int number2 = 2;
		return new int[] {number1, number2};
	}
}
```
Способ 2 - создать класс с двумя полями примитивного типа
```Java
class Something{
	public static MyResult something() {
		int number1 = 1;
		int number2 = 2;
		return new MyResult(number1, number2);
	}
}
```
    
Допустим, необходимо, чтобы метод возвращал два значения разных примитивных типов.
Предложите способы и подтвердите примерами.
**Ответ.**
Создать класс с двумя полями разных примитивных типов
```Java
class Something {
	public static MyResult something() {
		int number1 = 1;
		int number2 = 2;
		return new MyResult(number1, number2);
	}
}
```

Что такое иммутабельный объект? 
Опишите 2 способа создания иммутабельных объектов. 
Подсказка. Способ 1 - класс материала в classes2. 
Какой альтернативный? 
Подсказка - ключевое слово final для полей не использовать.
Создайте иммутабельный класс для вещества по альтернативному способу.  
**Ответ.** Иммутабельный объект - это объект чьё состояние  после создания нельзя изменить.  
Способ 1  
    1.Не создавать методы «установки» - методы, которые изменяют поля или объекты, на которые ссылаются поля.  
    2.Сделать все поля final и private  
    3.Сделать класс final  
Способ 2  
1.Не создавать методы «установки» - методы, которые изменяют поля или объекты, на которые ссылаются поля.  
2.Сделать все поля private и final   
3.Сделать privat конструтор и метод для создания объектов  
**Источник.** https://docs.oracle.com/javase/tutorial/essential/concurrency/immutable.html

Даны 2 класса.
```Java
        final class Material {
		private final String name;
		private final double density;
		...
	}
	class Runner {
		private static void printMaterial(final Material material) {
       		 	System.out.println(material);
		}
		public static void main(String[] args) {
        		Material steel = new Material("steel",7850);
        		printMaterial(steel);
		}
	}
```
В методе printMaterial() по ссылке material создается новый объект или имеется доступ к объекту new Material("steel",7850)? 
Какой пример можно использовать для обоснования ответа?  
**Ответ.** В методе printMaterial() по ссылке material имеется доступ new Material("steel",7850)
```Java
        final class Material {
		private final String name;
		private final double density;
		...
	}
	class Runner {
		private static void printMaterial(final Material material) {
       		 	System.out.println(material);
		}
		public static void main(String[] args) {
        		Material steel = new Material("steel",7850);
        		printMaterial(steel); // Вывод - Material@16d3586 
                System.out.println(steel); // Вывод -  Material@16d3586
		}
	}
```

Класс для комплексного числа содержит два поля:
```Java
	class Complex {
		private double re;
		private double im;
		…
	}
```
Реализуйте в данном классе методы: plus() для операции + и add() для +=.
Приведите пример использования каждого метода.
Реализуйте эти же методы при условии, что класс Complex является иммутабельным. 
***Ответ***
```java
class Complex {
    private double re;
    private double im;

    public Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public Complex plus (Complex c)
    {
        return new Complex (re + c.re, im + c.im);
    }

    public Complex add (Complex c)
    {
        re += c.re;
        im += c.im;
        return this;
    }
}
```
```java
final class Complex {
    private final double re;
    private final double im;

    public Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public Complex plus (Complex c)
    {
        return new Complex (re + c.re, im + c.im);
    }

    public Complex add (Complex c)
    {
        return new Complex(re + re + c.re, im + im + c.im);
    }
}
```

Для чего предназначен метод toString()?
В каких случаях он вызывается?  
**Ответ.** Возвращает представление объекта в виде строки. Метод вызывается автоматически, когда объект выводится методами println(), print() и некоторыми другими.                                                            
**Источник.** И.Блинов стр.112,113

Как реализован метод toString() в классе Object?  
**Ответ.** Метод toString() класса Object возвращает строку с описанием объекта в виде: getClass().getName() + '@' + Integer.toHexString(hashCode())
**Источник.** И.Блинов стр.113

Для чего предназначен метод equals()?
В каких случаях он вызывается?   
**Ответ.** Предназначен для использования и переопределения в подклассах с выполнением общих соглашений о сравнении содержимого двух объектов одного и того же типа. Автоматически вызывается при сравнении объектов в коллекции.  
**Источник.** И.Блинов стр.113

Как реализован метод equals() в классе Object?  
**Ответ.** Реализация метода в классе Object возвращает истину только в том случае, если обе ссылки указывают на один и тот же объект, а конкретно:
```Java
 public boolean equals(Object obj) {
            return (this == obj);
            }
```
**Источник.** И.Блинов стр.113

В чем различие между методом equals() и операции ==?
В каких случаях применение метода equals() и операции == эквивалентно?  
**Ответ.** Операция == сравнивает адреса ссылок на объект, а equals() сравнивает содержимое объектов.
			Применение метода equals() и операции == эквивалентно в случае если у двух объектов одинаковый адрес в памяти.  
**Источник.** И.Блинов стр.113

Eclipse в стандартной конфигурации генерирует начало метода equals() следующим образом:
```Java
    public boolean equals(Object obj) {
    if (this == obj)
    return true;
    if (obj == null)
    return false;
```
С чем связаны данные проверки, которые кажутся лишними?  
**Ответ.** 
```Java
	  if (this == obj) - проверяется находятся ли два объекта по одному и тому же адресу в памяти  
          if (obj == null) - проверяется не равняется ли null сравниваемый объект
```
**Источник.** И.Блинов стр.113

Что такое garbage collection?
**Ответ.** Сборка мусора - низкоприоритетный процесс, который запускается периодически и освобождает память,
			использованную ненужными более объектами.
**Источник.** И. Блинов. Java. Методы программирования. с. 118.
    
Перечислите случаи, когда JVM отдает управление на garbage collector.
**Ответ.** JVM обычно запускает сборщик мусора при низком уровне свободной памяти.
			Если памяти недостаточно даже после восстановления, JVM генерирует исключение OutOfMemoryError
**Источник.** https://javarush.ru/groups/posts/917-sborka-musora

Как сделать так, чтобы JVM сразу перешла в режим сборки мусора?
**Ответ.** Данный код запрашивает запуск GC:
```Java
        System.gc()
        Runtime.getRuntime().gc()
```
**Источник.** https://javarush.ru/groups/posts/917-sborka-musora

Гарантирует ли garbage collector, что приложение в любом случае не будет иметь проблемы с недостатком памяти? 
Обоснуйте ответ.
**Ответ.** Не гарантирует, т.к. из-за ошибок в коде могут быть медленные утечки памяти.Также ошибки могут
			возникать из-за операций,которые требуют различного объема памяти(большего, чем доступной) для вычислений.
**Источник.** https://overcoder.net/q/405670/java-garbage-collector

Для чего предназначен метод finalize()?
Какой недостаток у метода?
**Ответ.** Данный метод предназначен для автоматического освобождения системных ресурсов, занимаемых объектом,
			на котором будет метод вызван.
			Недостатком является то,что при вызове finalize() вы заставите JVM удерживать все другие объекты,
			на которые ссылается финализуемый объект.Также данный метод может и не вызываться GC
**Источник.** https://coderoad.ru/9556827/%D0%9A%D0%B0%D0%BA-finalize-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-%D0%B2-java

Для чего предназначены оболочечные классы?
Как они называются на инглише?
**Ответ.** Оболоченные классы, или "wrapper classes", предназначены для добавления новых возможностей
работы с привычными типами
**Источник.** https://docs.oracle.com/javase/tutorial/java/data/numberclasses.html

В чем преимущество примитивных типов перед соответствующими оболочечными классами?
**Ответ.** Переменные примитивных типов хранятся в стеке, в то время как ссылочные типы ссылаются
			на объекты в куче,отсюда и разница в скорости доступа и расхода памяти
**Источник.** https://topjava.ru/blog/primitives-and-referenses

Что такое autoboxing и unboxing?
**Ответ.** Autoboxing - преобразования примитивных типов в эквивалентные объекты.	
			Unboxing - процесс преобразования объектов в соответствующие им примитивные типы
**Источник.** https://javarush.ru/groups/posts/706-avtoupakovka-i-raspakovka-v-java

Дан код:
	Integer a = 3, b =7;
	Long c = a + b;
	Перечислите все операции, где задействованы autoboxing и unboxing.
**Ответ.** 	Long c = a + b;
			содержит синтаксическую ошибку.
				Правильно будет
				Long c = (long)(a + b);
				Используются операции:
				Integer a = new Integer(3);
				Integer b = new Integer(7);
				int a1 = a.intValue();
				int b1 = b.intValue();
				long c1 = a1 + b1;
				Long c = new Long(c1);

Дан корректный раннер-класс. 
Будет ли ошибка компиляции, если удалить модификатор static из сигнатуры метода main()? 
Обоснуйте ответ.
Что произойдет, если отправить на выполнение измененный класс?
**Ответ.** Сигнатура метода останется корректной, ошибки компиляции не будет.
			При выполнении такого раннер-класса будет ошибка:
			Error: Main method is not static in class Runner, please define the main method as:
			public static void main(String[] args).

Дан класс.
```Java
	class Runner {
		public static void main(String[] args) {
        		System.out.println("Hello, world!");
		}
	}
```
Запрещается изменять синий код, т.е. метод main().
Добавить код в класс Runner, так чтобы в результате запуска этого класса из под JVM в консоли был следующий результат:
I am java.
Hello, world!
**Ответ.** 
```Java
    public class Runner {
		static {
			System.out.println("I am java.");
		}
        public static void main(String[] args) {
            System.out.println("Hello, world!");
        }
    }
```

